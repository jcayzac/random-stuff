<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<style>
* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
#list {
	position: relative;
	padding-top: 50px;
	background: #888;
	width: 50%;
	margin-bottom: 80px;
	height: 200px;
	overflow: scroll;
}

.post {
	padding-top: 2em;
	width: 100%;
	min-height: 3em;
}
	</style>
</head>
<body>
<div id="container">
	<header>
		<h1>title</h1>
	</header>
	<div id="list">
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
		<article class="post">xxxx</article>
	</div>
	<footer>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
		Bla bla bla<br>
	</footer>
</div>
<script>
(function (global, document, Object, undefined) {
	"use strict";
	var prefixes = ['ms', 'webkit', 'moz', 'o'], prefixCount = length(prefixes)

	/**
	 * If **obj[assign]**
	 */
	function prefixHell(obj, name, assign) {
		var cap = capitalize(name)
		obj[assign] = obj[assign] || obj[name] || obj['webkit' + cap] || obj['WebKit' + cap] || obj['moz' + cap] || obj['Moz' + cap] || obj['ms' + cap]

		if (!obj[assign]) {
			for (var i = -1, cap = capitalize(name), p, n=obj[name]; p = prefixes[++i], i < prefixCount && !n;)
				n = obj[p + cap]
			obj[assign] = n
		}
	}

	// Resolve a few methods
	for (var methods = [
			Element.prototype, 'matchesSelector', 'matches',
			global, 'requestAnimationFrame',,
			global, 'cancelAnimationFrame',,
		], l = length(methods), i = -1; i < l;)
		prefixHell(methods[++i], methods[++i], methods[++i])

	/**
	 * Convert anything to an array.
	 *
	 * @param {*} x Any value.
	 * @return {Array}
	 */
	function toArray(x) { return Array.isArray(x) ? x : Array.prototype.slice.call(x || []) }

	/**
	 * @param {!Object} a  An array-like object.
	 * @return {Number} The length of **a**.
	 */
	function length(a) { return a.length >>> 0 }

	/**
	 * Get the name of an object's class or type.
	 * Works with any type.
	 *
	 * @param {*} x Any value.
	 * @return {string}
	 */
	function typeOf(x) { return Object.prototype.toString.call(x).slice(8, -1) }

	/**
	 * Treats undefined as null.
	 * @param {*}       O  A value.
	 * @param {*} DEFAULT  Default value.
	 * @return {*}         The value if it's defined and not null, **DEFAULT** otherwise.
	 */
	function defaults(O, DEFAULT) { return O == null ? DEFAULT : O }

	/**
	 * Check that object **x** is an instance of class **c**.
	 * Works with any type.
	 *
	 * @param {*}         x  Any value.
	 * @param {!Function} c  A class.
	 * @return {boolean}
	 */
	function isInstanceOf(x, c) {
		for (var cp = c.prototype, r = x instanceof c;
		     x != null && !r;
		     x = typeof x === 'object' ? Object.getPrototypeOf(x) : null
		    ) r = x.constructor === c || cp.isPrototypeOf(x)

		return r
	}

	/**
	 * Return the class of **x**.
	 * Works with any type.
	 *
	 * @param {*}         x  Any value.
	 * @return {Function}
	 */
	function classOf(x) {
		if (x != null) {
			var ctor = x.constructor, type = typeof x

			return ctor ? ctor : type === 'object' ? Object.getPrototypeOf(x) : global[capitalize(type)]
		}
	}

	/**
	 * Returns an array of the unique items found in **a**.
	 * Works with any iterable.
	 *
	 * @param {{length: number}} a  An iterable object.
	 * @return {Array}
	 */
	function uniqueItems(a) {
		for (var r = [], l = length(a), i = -1, e; e = a[++i], i < l;)
			r.indexOf(e) < 0 && r.push(e)
	}

	// If we have Set and iterators we can do (much) better:
	if (global.Set) try {
		// Only Mozilla supports ES6 comprehensions right now
		uniqueItems = Function('a', 'return[x for(x of Set(a))]')
	} catch(e) {
		// V8-with-harmony-switched-on has Set but doesn't support iterating yet
		// WebKit has a weird empty SetIterator class
		if (Set.prototype.keys && !global.SetIterator) uniqueItems = function(a) {
			for (var s = new Set(a), r = new Array(s.size), i=-1, iter = s.keys(), v = iter.next(); !v.done; v = iter.next())
				r[++i] = v.value
			return r
		}
	}

	/**
	 * Copy object **s**'s properties into object **d**.
	 *
	 * @param {Object} d  Destination object.
	 * @param {Object} s  Source object.
	 */
	function shallowCopy(d, s) {
		if (d && s)
			for (var a = Object.getOwnPropertyNames(s), l = length(a), k; l;)
				k = a[--l], Object.defineProperty(d, k, Object.getOwnPropertyDescriptor(s, k))
	}

	/**
	 * Create a function that can invoke function **fn** only once every **ms** milliseconds.
	 * Only the most recently-passed arguments are used (intermediate calls are dropped).
	 *
	 * @param {Function} fn  A function.
	 * @param {number}   ms  Milliseconds.
	 * @return {Function}
	 */
	function throttle(fn, ms) {
		var timer, last = 0
		return function() {
			var args = arguments, self = this
			timer = timer || setTimeout(function() {
				last = Date.now()
				timer = fn.apply(self, args), 0
			}, Math.max(0, ms + last - Date.now()))
		}
	}

	/**
	 * Create a string like **x** but with the first character made uppercase and the rest lowercase.
	 *
	 * @param {string} x  A string.
	 * @return {string}
	 */
	function capitalize(x) {
		return x && x[0].toUpperCase() + x.slice(1).toLowerCase()
	}

	/**
	 * Execute a function asynchronously, as soon as possible.
	 *
	 * @param {Function} fn    A function
	 * @param {Array}    args  Arguments to pass to **fn**.
	 */
	var nextTick = (function() {
		var Q = [], MO, next, node, i

		function schedule() {
			next = next || setTimeout(flush, 0)
		}

		function flush() {
			for (var i=-1, l=length(Q), t; t=Q[++i], i<l;) t[0].apply(null, t[1])
			Q.length=next=0
		}

		// mutation observers are faster than timers
		if (MO = global.MutationObserver || global.WebKitMutationObserver) {
			node = document.createTextNode('')
			schedule = function() { node.data = (i = ++i % 2) }
			new MO(flush).observe(node, { characterData: true })
		}

		return function(fn, args) {
			Q.push([fn, args]) === 1 && schedule()
		}
	})()

	// Polyfill for ES6 promises
	if (!(global.Promise && Promise.resolve && Promise.reject && Promise.all && Promise.race && (function() {
		var resolve;
		new Promise(function(r) { resolve = r })
		return classOf(resolve) === Function
	})())) global.Promise = (function() {
		var fulfill = resolution(1),
			reject  = resolution(2)

		function resolve(promise, value) {
			// TODO: remove !
			if (promise === value || !handleThenable(promise, value)) fulfill(promise, value)
		}

		function resolution(n) {
			function invokePublish(promise) {
				publish(promise, promise._state = n)
			}

			return function(promise, detail) {
				if (promise._state === undefined) {
					promise._state = 0
					promise._detail = detail

					nextTick(invokePublish, [promise])
				}
			}
		}

		function invokeResolver(resolver, promise) {
			function ok(value) { resolve(promise, value) }
			function ng(reason) { reject(promise, reason) }

			try { resolver(ok, ng) }
			catch(e) { ng(e) }
		}

		function invokeCallback(settled, promise, callback, detail) {
			var hasCallback = classOf(callback) === Function, value, error

			if (hasCallback)
				try { value = callback(detail) }
				catch(e) { error = e }
			else value = detail

			if (!handleThenable(promise, value)) {
				if (error) reject(promise, error)
				else if (hasCallback || settled === 1) resolve(promise, value)
				else if (settled === 2) reject(promise, value)
			}
		}

		function handleThenable(promise, value) {
			var resolved

			try {
				if (classOf(value) === Function || isInstanceOf(value, Object)) {
					if (classOf(value.then) === Function) return value.then.call(value, function(val) {
						return resolved || (value === val ? fulfill : resolve)(promise, val), resolved = true
					}, function(val) {
						return resolved || reject(promise, val), resolved = true
					}), true
				}
			} catch (error) {
				return resolved || reject(promise, error), true
			}
		}

		function subscribe(promise, child, ok, ng) {
			promise._subscribers = promise._subscribers.concat(child, ok, ng)
		}

		function publish(promise, state) {
			for (var subscribers = promise._subscribers, detail = promise._detail, i=0, l=length(subscribers); i<l; i+=3)
				invokeCallback(state, subscribers[i], subscribers[i + state], detail)

			promise._subscribers = []
		}

		/**
		 * @constructor
		 */
		function P(resolver) {
			if (!this) return new P(resolver)

			this._subscribers = []
			invokeResolver(resolver, this)
		}

		P.prototype = {
			constructor: P,

			_state: undefined,
			_detail: undefined,

			then: function(ok, ng) {
				var promise = this, thenPromise = P(function() {})

				if (promise._state) nextTick(invokeCallback, [promise._state, thenPromise, arguments[promise._state - 1], promise._detail])
				else subscribe(promise, thenPromise, ok, ng)

				return thenPromise
			},

			'catch': function(ng) {
				return this.then(null, ng)
			}
		}

		P.all = function(promises) {
			return P(function(ok, ng) {
				function resolver(index) {
					return function(value) { resolveAll(index, value) }
				}

				function resolveAll(index, value) {
					results[index] = value
					if (!--remaining) ok(results)
				}

				var results = [], l = remaining = length(promises), p, i
				if (!remaining) ok([])

				for (i = -1; p = promises[++i], i < l;)
					if (classOf(p && p.then) === Function) p.then(resolver(i), ng)
					else resolveAll(i, p)
			})
		}

		P.race = function(promises) {
			return P(function(ok, ng) {
				for (var p, i = -1, l = length(promises); p = promises[++i], i < l;)
					if (classOf(p && p.then) === Function) p.then(ok, ng)
					else ok(p)
			})
		}
		P.resolve = function(v) {
			return classOf(v) === P ? v : P(function(ok) { ok(v) })
		}

		P.reject = function(r) {
			return P(function (ok, ng) { ng(r) })
		}

		return P
	})()






	// DOM

	function bind_unbind_(t, e, fn, c) {
		var a = e.split(' '),
			l = length(a)
		while (l) c.call(t, a[--l], fn, false)
	}

	//function bind(target, )






	function Duh(o) {
		if (!this) return new Duh(o)

		if (isInstanceOf(o, Function)) {
			console.log('function', o)
		}
	}




	function ready(fn) {
		document.addEventListener("DOMContentLoaded", fn)
	}


	function Paging(parent) {
		if (!this) return new Paging(parent)

		this.parent = parent
		this.setupEvents()
	}

	Paging.prototype = {
		constructor: Paging,
		setupEvents: function() {
			var o = this, parent = o.parent
			document.addEventListener('scroll', o)
			document.addEventListener('resize', o)
			document.addEventListener('load', o)
			parent.addEventListener('scroll', o)
			parent.addEventListener('resize', o)
		},
		handleEvent: function(event) {
			switch(event.type) {
				case 'scroll':
				case 'resize':
				case 'load':
					this.updateContentThrottled(event)
					break
			}
		},
		updateContent: function(event) {
			console.log('update')
		},
	}
	Paging.prototype.updateContentThrottled = throttle(Paging.prototype.updateContent, 1000)


	ready(function() {
		new Paging(document.getElementById('list'))
	});
})(window, document, Object);
</script>
</body>
</html>


list.getBoundingClientRect()